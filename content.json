[{"title":"浏览器兼容问题","date":"2017-04-25T13:57:27.000Z","path":"2017/04/25/浏览器兼容问题/","text":"浏览器兼容是前端开发人员必须掌握的一个技能,要认识到浏览器的兼容问题，首先要了解浏览器的内核，浏览器内核一般分为四种：123456789Trident(IE内核)：IE浏览器，360浏览器等等Gecko(Firefox内核)： Mozilla Firefox等Webkit(Safari内核,Chrome内核原型,开源)：Google Chrome，傲游浏览器3，Android 默认浏览器Blink(Google和Opera)：Chrome（28及往后版本）、Opera（15及往后版本）Presto(Opera前内核)： Nokia 770 等 对浏览器兼容问题，我一般是这样分类的，HTML兼容，Javascript兼容，CSS兼容。其中html相关问题比较容易处理，无非是使用了低版本浏览器无法识别的标签致其不能解析，所以平时注意一点就是。特别是HTML5增加了许多新标签，低版本浏览器不识别新标签，其中的代表为IE6-8。 下面就说几个常见的浏览器兼容性问题，要是是兼容性问题太多，平常多多注意就好，下面几个仅供参考 javascript兼容性问题在javascript中，各个浏览器基本语法差距不大，其兼容问题主要出现在各个浏览器的实现上，尤其对事件的支持有很大问题。 1 事件绑定和解绑事件 事件绑定IE为attachEvent，标准浏览器为addEventListener 事件解绑IE为detachEvent，标准浏览器为removeEventListener 2 触发事件对象（触发事件的元素被认为是目标target）: IE下，window.event对象有srcElement属性，但没有target属性。 Firefox下，e对象有target属性，但没有srcElement属性。 Chrome下，e对象同时具有target和srcElement属性。==解决方案==：event.srcElement ? event.srcElement : event.target来兼容。 3 阻止事件的默认行为 ： IE 中阻止事件的默认行为需要将window.event.returnValue属性设置为false。 非IE阻止事件的默认行为需要调用 e.preventDefault() 方法。==解决方案==：条件判断浏览器是否具有event.preventDefault再做相应处理。 4 阻止事件冒泡： IE阻止事件冒泡需要设置window.event.cancelBubble = true。 非IE阻止事件冒泡需要调用e.stopPropagation()。==解决方案==：条件判断浏览器是否具有event.stopPropagation再做相应处理。 5 IE里table和tr的innerhtml不管用，要降到td一级使用innerHTML。 6 鼠标滚轮事件 除Firefox使用DOMMouseScroll事件，其余浏览器使用mousewheel事件 ==在IE和Chrome下通过event.wheelDelta==的返回值可以知道滚轮是向上滚的还是向下滚的，当返回值为正值的时候，说明是向上滚，当返回值是负值的时候，说明是向下滚；但是event.wheelDelta在火狐下并不起作用，==在Firefox下需要通过event.detail==来知道滚轮是向上滚的还是向下滚，火狐下还有一点不同：当返回值为正值的时候，说明是向下滚，当返回值是负值的时候，说明是向上滚 示例代码： 123456789101112131415161718192021222324252627window.onload = function () &#123; var oDiv = document.getElementById(&apos;div1&apos;); function onMouseWheel(ev) &#123;/*当鼠标滚轮事件发生时，执行一些操作*/ var ev = ev || window.event; var down = true; // 定义一个标志，当滚轮向下滚时，执行一些操作 down = ev.wheelDelta?ev.wheelDelta&lt;0:ev.detail&gt;0; if(down)&#123; oDiv.style.height = oDiv.offsetHeight+10+&apos;px&apos;; &#125;else&#123; oDiv.style.height = oDiv.offsetHeight-10+&apos;px&apos;; &#125; if(ev.preventDefault)&#123;/*FF 和 Chrome*/ ev.preventDefault();// 阻止默认事件 &#125; return false; &#125; addEvent(oDiv,&apos;mousewheel&apos;,onMouseWheel); addEvent(oDiv,&apos;DOMMouseScroll&apos;,onMouseWheel); &#125; function addEvent(obj,xEvent,fn) &#123; if(obj.attachEvent)&#123; obj.attachEvent(&apos;on&apos;+xEvent,fn); &#125;else&#123; obj.addEventListener(xEvent,fn,false); &#125; &#125; 7 event.x与event.y问题 IE下,event对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.==解决方法==：使用mX(mX = event.x ? event.x : event.pageX;)来代替IE下的event.x或者Firefox下的event.pageX. 8 AJAX问题 IE下new ActiveXObject(“Microsoft.XMLHTTP”) 非IEnew XMLHttpRequest()==解决方案：==12345678var xmlHttp;function createxmlHttpRequest() &#123; if (window.ActiveXObject) &#123; xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; else if (window.XMLHttpRequest) &#123; xmlHttp=new XMLHttpRequest(); &#125;&#125; 9 IE与非IE的父元素的区别 IE父元素节点：obj.parentElement 非IE父元素节点：obj.parentNode 10 input.type属性问题 IE下input.type属性为只读，但是Firefox下input.type属性为读写。==解决方法：== 不修改input.type属性。如果必须要修改，可以先隐藏原来的input，然后在同样的位置再插入一个新的input元素。 css兼容问题 1 CSS透明 IE：filter: progid:DXImageTransform.Microsoft.Alpha(opacity=50);； 非IE：opacity: 0.5; 2 盒模型不一致 IE盒模型中width和height包括padding和border 标准盒模型中width和height不包括padding和borddr==解决办法：==设置box-sizing：border-box;width和height就包括padding和border了 3 无法定义1px左右高度的容器 1.IE6下这个问题是因为默认的行高造成的,解决的技巧也有很多： 1例如:overflow:hidden zoom:0.08 line-height:1px 4 超链接访问过后hover样式就不出现的问题 被点击访问过的超链接样式不在具有hover和active了,很多人应该都遇到过这个问题,解决技巧是改变CSS属性的排列顺序: L-V-H-A 1234a:link &#123;&#125; a:visited &#123;&#125; a:hover &#123;&#125; a:active &#123;&#125; 5 页面的最小宽度 IE不识别min,但实际上它把正常的width和height当作有min的情况来使，要实现最小宽度，可用下面的方法： 1234#container&#123; min-width: 600px; width:expression(document.body.clientWidth＜ 600? “600px”: “auto” );&#125; 如果只用宽度和高度，正常的浏览器里这两个值就不会变，如果只用min-width和min-height的话，IE下面根本等于没有设置宽度和高度。 比如要设置背景图片，这个宽度是比较重要的。要解决这个问题，可以这样： 12345678910#box&#123; width: 80px; height: 35px;&#125;html&gt;body #box&#123; width: auto; height: auto; min-width: 80px; min-height: 35px;&#125; 6 DIV浮动IE文本产生3象素的bug 左边对象浮动，右边采用外补丁的左边距来定位，右边对象内的文本会离左边有3px的间距. 12345678910&lt;style&gt; #box&#123; float:left; width:800px;&#125; #left&#123; float:left; width:50%;&#125; #right&#123; width:50%;&#125; *html #left&#123; margin-right:-3px; //这句是关键&#125; &lt;/style&gt;&lt;div id=”box”&gt; &lt;div id=”left”&gt;&lt;/div&gt; &lt;div id=”right”&gt;&lt;/div&gt;&lt;/div&gt; 7 E6下图片下有空隙产生 解决这个BUG的技巧有很多,可以是改变html的排版,或者设置img为display:block或者设置vertical-align属性为vertical-align:top/bottom/middle/text-bottom 都可以解决. 8 元素水平居中问题 FF: margin:0 auto; IE: 父级{ text-align:center; } HTML兼容问题HTML的兼容问题说白了就是低版本浏览器不认识H5的新标签的原因，在火狐和chrome之类的浏览器中，遇到不认识的标签，只要给个display:block属性，就能让这个元素成为一个类似div的元素，但是到IE上就很恶心了，它不认识就是不认识，你在html和css里添加什么它都不理你。那怎么解决呢？只要加一行JS代码就可以解决了1document.createElement(&quot;这里写标签名&quot;); 这条语句可以理解为：我要创建一个新标签，IE你别再说你不认识了！但是h5的标签有很多，手工一个个创建耗时不说，还可能写错或者漏掉，到时候出了BUG又是无从下手了，所以，在这里推荐两款专门为了h5标签兼容IE所开发的插件，你只需要引入它，不需要做多余的事：Bsie这个名字很有趣，其实看完它的源码后会发现，它就是帮我们把所有的h5标签都创建了一遍，免去了我们手工创建的时间。html5shiv和上面的插件功能一样,它会帮我们把不是h5标签里的自定义标签也创建一次，这意味着我们在创建一个自定义标签的时候，不用考虑这个标签会不会生效了，真是贴体入微。","tags":[{"name":"浏览器兼容","slug":"浏览器兼容","permalink":"https://angeljie889.github.io/tags/浏览器兼容/"}]},{"title":"日常String、Number、Array、Math和Json方法","date":"2017-03-20T14:36:36.000Z","path":"2017/03/20/日常String、Number、Array、Math和Json方法/","text":"前端日常使用的方法有很多种，为了方便使用和查询，整理如下 字符串方法1234567891011121314String.length() 返回字符串的长度String.charAt() 返回字符串中指定位置的字符String.charCodeAt() 返回指定位置的字符的Unicode 编码String.indexOf() 返回指定值在调用该方法的字符串中首次出现的位置String.lastIndexOf() 返回指定值在调用该方法的字符串中最后出现的位置String.slice() 提取字符串中的一部分，并返回这个新的字符串String.split() 通过一个指定的字符串分隔符，把原字符串分割成一个数组String.substring() 截取指定位置之间的字符串String.substr() 截取指定起始位置和长度的子字符串String.toLowerCase() 把字符串全部转成小写String.toUpperCase() 把字符串全部转成大写String.trim() 去掉字符串首尾的全部空格str.repeat(num) 将str复制几分并返回，num代表复制的次数。str.includes() 参数：1、要查找的字符串2、起始位置返回布尔值 注意 slice(),substr(),substring()方法的不同三种方法都是返回被操作字符串的子字符串，都接受一或者两个参数，第一个参数指定子字符串的开始位置，第二个参数在指定的情况下表示子字符串在哪里结束。具体来说，slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置，而==substr() 的第二个参数指定的是返回的字符个数== 数组方法1234567891011121314151617181920212223242526272829303132arr.every(fun) 检测数值元素的每个元素是否都符合条件。arr.filter(fun) 检测数值元素，并返回符合条件所有元素的数组。arr.map(fun) 让数组的每一项都执行一次给定的函数,返回值是数组arr.forEach(fun) 让数组的每一项都执行一次给定的函数arr.some(fun) 检测数组元素中是否有元素符合指定条件。arr.sort(fun) 对数组的元素进行排序arr.push() 添加一个或多个元素到数组的末尾arr.unshift() 添加一个或多个元素到数组的头部arr.pop() 删除数组最后一项元素arr.shift() 删除数组第一个元素arr.concat(arr) 将传入的数组或非数组值与原数组合并,组成一个新的数组并返回arr.reverse() 颠倒数组中元素的位置arr.join(str) 用于把数组中的所有元素通过指定的分隔符进行分隔,放入字符串。arr.slice(num) 截取数组中一部分，并返回这个新的数组arr.splice(num) 用新元素替换旧元素以此修改数组的内容，3个参数，2个参数代表删除arr.toString() 把数组转换为字符串，并返回结果。arr.valueOf() 返回数组对象的原始值。arr.indexOf（） 参数在数组中的下标，返回值为number；-1代表数组中没有这个参数arr.from() 用于将类数组对象转为真正的数组arr.of() 用于将一组参数，转换为数组。 Arr.sort(function(a,b)&#123; //return a - b (从小到大)； //return b - a（从大到小） &#125;) 数组（json）随机排序： Arr.sort(function() &#123; return 0.5 - Math.random(); &#125;)（随机排序） //获取数组元素最小值和最大值 Math.min.apply(null,arr)； Math.max.apply(null,arr)； Math方法1234567891011Math.ceil() 对数进行向上取整Math.floor() 对数进行向下取整Math.round() 对数进行四舍五入Math.abs() 取数的绝对值Math.random() 取0-1之间的随机数，不包含1Math.min() 取（）里面的最小值Math.pow(a,b) a的b次方Math.pow(a,1/b) a的开b次方Math.sqrt(a) a的开方Math.sign() 判断一个数字是正数，负数还是零Math.hypot(...values) 返回所有参数的平方和的平方根(勾股定理) json操作方法12JSON.parse(str); 由JSON字符串转换为JSON对象JSON.stringify(obj); 将JSON对象转化为JSON字符","tags":[{"name":"string","slug":"string","permalink":"https://angeljie889.github.io/tags/string/"},{"name":"number","slug":"number","permalink":"https://angeljie889.github.io/tags/number/"},{"name":"array","slug":"array","permalink":"https://angeljie889.github.io/tags/array/"},{"name":"Math","slug":"Math","permalink":"https://angeljie889.github.io/tags/Math/"}]},{"title":"前端高性能优化","date":"2017-03-20T12:36:36.000Z","path":"2017/03/20/前端优化总结/","text":"前端优化主要是在性能上下功夫，只有这样才能给用户带来更好的体验，而且不管在面试中还是实际需求中，网站优化都是重中之重，所以，了解前端优化很重要。 一般说来，web前端指网站业务逻辑之前的部分，包括浏览器加载、网站视图模型、图片服务、CDN服务等，主要优化手段有浏览器访问、使用反向代理才、CDN等。 浏览器请求处理流程如下图： 那么到底应该如何实现页面优化呢？可以从以下几点方面来实现： HTML部分1. 避免使用iframeiframe也叫内联frame，可将一个HTML文档嵌入另一个HTML文档中。iframe的好处是，嵌入的文档独立于父文档，通常也借此使浏览器模拟多线程。缺点是： ①虽然iframe能模拟多线程，但主流浏览器的同域名并行下载数是不变的，浏览器对同域名的链接总是共享浏览器级别的连接池， 即使是不同窗口或标签页的同域名网页。 ②在页面加载时，iframe会阻塞父文档onload事件的触发。并且有些浏览器需在触发onload事件后才能被触发onunload事件。故用户用onload事件长久未触发而离开页面时，不会触发onunload事件。 ※不兼容IE6~8的解决方案：使用JavaScript动态加载iframe元素或动态设置其src属性。12&lt;iframe id=ifr &gt;&lt;/iframe&gt;document.getElementById( ‘ifr’ ).setAttribute( ‘src’ , ‘url ’ ); ③iframe是文档内最消耗资源的元素之一，即使是空iframe的开销也是昂贵的。 2. 避免空连接属性空连接指：img、link、script 和 iframe元素的src或href属性的值为空。（如src = ””）设置了空连接后浏览器依然会以默认规则发送请求： ①IE6~8中只有img元素会出问题：IE会将img的空地址解析为当前页面地址的目录地址并请求。如当前网页地址为http://aaa.com/bb/c.html，img的地址会被解析为http://aaa.com/bb ②早些版本的Webkit和Firefox会将空连接解析为当前页面的地址。在ios与android中此问题较严重。如果页面有多个空连接属性元素，会增加服务器的请求次数。 ③幸运的是，主流浏览器对iframe的src属性值为空时，会解析为about:blank地址，而不发送额外请求。 3. 避免节点深层级嵌套层级越深的节点在初始化构建时，所占内存越多。通过浏览器HTML解析器会将整个HTML文档的结构存储为DOM树结构。当节点嵌套层次越深，构建的DOM书层次也越深。 4. 缩减HTML文档大小 ①删除对执行结果无影响的空格空行和注释； ②避免table布局； ③使用HTML5； 5.显式指定文档字符集在HTML页面开时指定字符集有助于浏览器立即开始解析HTML代码。HTML文档通常被解析为一序列的带字符集编码信息的字符串，通过Internet传送。字符集编码在HTTP响应头中，或HTML标记中指定。浏览器通过指定的字符集，吧编码解析为可现实在屏幕上的字符。若浏览器无法获知页面的编码字符集，一般会在执行脚本和渲染页面之前，先将字节流缓存，再搜索可进行解析的字符集 或 以默认字符集来解析。 6. 显示设置图片的宽高有时需要在页面加载完之前，就对页面布局进行定位。若页面中的图片没指定尺寸，或尺寸与实际图片大小不符，浏览器会在图片下载完成后再”回溯”该图片并重新显示，从而浪费时间。故最好为页面的图片设置指定尺寸（行内样式或CSS样式） 7. 避免脚本阻塞加载浏览器在解析常规script标签时，会等待script下载完毕后，才解析执行，之后的HTML代码就只能等待。 CSS1. 避免使用@importCSS2.1加入的@import，会使页面在加载时添加额外延迟。由于浏览器不能并行下载样式，会导致页面增添额外的往返耗时。而使用能并行下载样式，但任然是多次请求。 2. 避免AlphaImageLoader滤镜此滤镜能解决IE6即一下版本显示PNG图片的半透明效果，但会在加载图片时终止内容的呈现，并冻结浏览器。在每个元素(不仅仅是图片)都会运算一次，添加内存开支。应使用PNG8格式来代替，或用下划线(_filter)只针对IE6。 3. 避免CSS表达式CSS表达式是动态设置CSS属性的强大（但危险）方法。Internet Explorer从第5个版本开始支持CSS表达式12345678910111213141516隔1s切换一次背景颜色 input鼠标移入移出变换背景//cssbody&#123; background-color: expression( (new Date()).getSeconds()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; ); &#125;input &#123; star : expression( onmouseover=function()&#123;this.style.backgroundColor=&quot;green&quot;&#125;, onmouseout=function()&#123;this.style.backgroundColor=&quot;red&quot;&#125; ) &#125;//HTML&lt;body &gt; &lt;input type=&quot;text&quot;/&gt;&lt;/body&gt; css表达式算频率要比我们想象的多。千上万次并且可能会对你页面的性能产生影响。在页面滚动、乃至移动鼠标时都会要重新计算一次。随便移动鼠标都可以轻松达到10000次以上的计算量。 解决方案：如果样式属性必须在页面周期内动态地改变，使用事件句柄来代替CSS表达式，或者使用使用jQuery方法代替 4. 避免通配选择器优化选择器的原则是减少匹配时间。CSS选择器的匹配机制是：从右向左进行规制匹配的！ #header &gt; a { font-weight:blod;}这条规制实际是浏览器遍历页面所有a元素，并确定其父元素的id是否为header。 #header a {…} 后代选择器开销更大，在遍历页面的所有a元素后，会需向上遍历直到根节点。由此可知，选择器最右边的规制往往决定了向左移匹配的工作量。故最右边的选择规则 称之为关键选择器。 5. 避免单规则的属性选择器.selected [href=’#index’] {…}浏览器先匹配所有的元素，检查其是否有href属性并且值为“#index”，再分别向上匹配class为selected的元素。故应该避免使用关键选择器是单规则属性选择器的规则。 6.避免正则的属性选择器CSS3添加了复杂的属性选择器，通过类正则表达式进行匹配。但这些类型的选择器会比基于类别的匹配慢很多。 7.移除无匹配的样式 ①删除无用的样式，可缩减样式文件大小，加快加载速度。 ②对于浏览器，所有样式规则都会被解析后索引起来，即使是当前页面无匹配的规则！故移除无匹配的规则，减少索引项，加快浏览器查找速度。 JavaScript1.使用事件代理当过多的事件句柄被频繁触发时，页面反应会迟钝。如一个div有10个按钮，只需给div附加一次事件句柄，而不必给每个按钮添加一个句柄。 2.缓存选择器查询结果减少选择器查询的次数，并尽可能缓存选中的结果，便于以后的重用。123456789jQuery(&apos;#top&apos;).find(&apos;p.classA&apos;);...jQuery(&apos;#top&apos;).find(&apos;p.classB&apos;);//使用下面的方法 减少开销var cached = jQuery(&apos;#top&apos;);cached.find(&apos;p.classA&apos;);...cached.find(&apos;p.classB&apos;); 3.避免频繁的IO操作(读写操作)应减少对cookie或localstorage的操作，因为对它们进行操作的API是同步的，而它们是多个tab页面间共享的。多页面同时操作cookie和localstorage时，会存在同步加锁机制。 4. 避免频繁的DOM操作JavaScript访问DOM元素缓慢，应做到： ①缓存已经查询过的元素； ②线下更新完节点之后，在将它们添加到文档树中； ③避免使用JavaScript来修改页面布局。 5.使用微类库尽量避免使用大而全的类库，而是按需使用微类库来辅助开发。因为大而全的类库好多代码是不需要的，浪费加载时间 参考文章：高性能web推荐文章：唯快不破：Web 应用的 13 个优化步骤","tags":[{"name":"网站优化","slug":"网站优化","permalink":"https://angeljie889.github.io/tags/网站优化/"}]}]