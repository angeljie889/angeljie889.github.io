[{"title":"日常String、Number、Array、Math和Json方法","date":"2017-03-20T14:36:36.000Z","path":"2017/03/20/日常String、Number、Array、Math和Json方法/","text":"前端日常使用的方法有很多种，为了方便使用和查询，整理如下 字符串方法1234567891011121314String.length() 返回字符串的长度String.charAt() 返回字符串中指定位置的字符String.charCodeAt() 返回指定位置的字符的Unicode 编码String.indexOf() 返回指定值在调用该方法的字符串中首次出现的位置String.lastIndexOf() 返回指定值在调用该方法的字符串中最后出现的位置String.slice() 提取字符串中的一部分，并返回这个新的字符串String.split() 通过一个指定的字符串分隔符，把原字符串分割成一个数组String.substring() 截取指定位置之间的字符串String.substr() 截取指定起始位置和长度的子字符串String.toLowerCase() 把字符串全部转成小写String.toUpperCase() 把字符串全部转成大写String.trim() 去掉字符串首尾的全部空格str.repeat(num) 将str复制几分并返回，num代表复制的次数。str.includes() 参数：1、要查找的字符串2、起始位置返回布尔值 注意 slice(),substr(),substring()方法的不同三种方法都是返回被操作字符串的子字符串，都接受一或者两个参数，第一个参数指定子字符串的开始位置，第二个参数在指定的情况下表示子字符串在哪里结束。具体来说，slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置，而==substr() 的第二个参数指定的是返回的字符个数== 数组方法1234567891011121314151617181920212223242526272829303132arr.every(fun) 检测数值元素的每个元素是否都符合条件。arr.filter(fun) 检测数值元素，并返回符合条件所有元素的数组。arr.map(fun) 让数组的每一项都执行一次给定的函数,返回值是数组arr.forEach(fun) 让数组的每一项都执行一次给定的函数arr.some(fun) 检测数组元素中是否有元素符合指定条件。arr.sort(fun) 对数组的元素进行排序arr.push() 添加一个或多个元素到数组的末尾arr.unshift() 添加一个或多个元素到数组的头部arr.pop() 删除数组最后一项元素arr.shift() 删除数组第一个元素arr.concat(arr) 将传入的数组或非数组值与原数组合并,组成一个新的数组并返回arr.reverse() 颠倒数组中元素的位置arr.join(str) 用于把数组中的所有元素通过指定的分隔符进行分隔,放入字符串。arr.slice(num) 截取数组中一部分，并返回这个新的数组arr.splice(num) 用新元素替换旧元素以此修改数组的内容，3个参数，2个参数代表删除arr.toString() 把数组转换为字符串，并返回结果。arr.valueOf() 返回数组对象的原始值。arr.indexOf（） 参数在数组中的下标，返回值为number；-1代表数组中没有这个参数arr.from() 用于将类数组对象转为真正的数组arr.of() 用于将一组参数，转换为数组。 Arr.sort(function(a,b)&#123; //return a - b (从小到大)； //return b - a（从大到小） &#125;) 数组（json）随机排序： Arr.sort(function() &#123; return 0.5 - Math.random(); &#125;)（随机排序） //获取数组元素最小值和最大值 Math.min.apply(null,arr)； Math.max.apply(null,arr)； Math方法1234567891011Math.ceil() 对数进行向上取整Math.floor() 对数进行向下取整Math.round() 对数进行四舍五入Math.abs() 取数的绝对值Math.random() 取0-1之间的随机数，不包含1Math.min() 取（）里面的最小值Math.pow(a,b) a的b次方Math.pow(a,1/b) a的开b次方Math.sqrt(a) a的开方Math.sign() 判断一个数字是正数，负数还是零Math.hypot(...values) 返回所有参数的平方和的平方根(勾股定理) json操作方法12JSON.parse(str); 由JSON字符串转换为JSON对象JSON.stringify(obj); 将JSON对象转化为JSON字符","tags":[{"name":"string","slug":"string","permalink":"https://angeljie889.github.io/tags/string/"},{"name":"number","slug":"number","permalink":"https://angeljie889.github.io/tags/number/"},{"name":"array","slug":"array","permalink":"https://angeljie889.github.io/tags/array/"},{"name":"Math","slug":"Math","permalink":"https://angeljie889.github.io/tags/Math/"}]},{"title":"前端高性能优化","date":"2017-03-20T12:36:36.000Z","path":"2017/03/20/前端优化总结/","text":"前端优化主要是在性能上下功夫，只有这样才能给用户带来更好的体验，而且不管在面试中还是实际需求中，网站优化都是重中之重，所以，了解前端优化很重要。 一般说来，web前端指网站业务逻辑之前的部分，包括浏览器加载、网站视图模型、图片服务、CDN服务等，主要优化手段有浏览器访问、使用反向代理才、CDN等。 浏览器请求处理流程如下图： 那么到底应该如何实现页面优化呢？可以从以下几点方面来实现： HTML部分1. 避免使用iframeiframe也叫内联frame，可将一个HTML文档嵌入另一个HTML文档中。iframe的好处是，嵌入的文档独立于父文档，通常也借此使浏览器模拟多线程。缺点是： ①虽然iframe能模拟多线程，但主流浏览器的同域名并行下载数是不变的，浏览器对同域名的链接总是共享浏览器级别的连接池， 即使是不同窗口或标签页的同域名网页。 ②在页面加载时，iframe会阻塞父文档onload事件的触发。并且有些浏览器需在触发onload事件后才能被触发onunload事件。故用户用onload事件长久未触发而离开页面时，不会触发onunload事件。 ※不兼容IE6~8的解决方案：使用JavaScript动态加载iframe元素或动态设置其src属性。12&lt;iframe id=ifr &gt;&lt;/iframe&gt;document.getElementById( ‘ifr’ ).setAttribute( ‘src’ , ‘url ’ ); ③iframe是文档内最消耗资源的元素之一，即使是空iframe的开销也是昂贵的。 2. 避免空连接属性空连接指：img、link、script 和 iframe元素的src或href属性的值为空。（如src = ””）设置了空连接后浏览器依然会以默认规则发送请求： ①IE6~8中只有img元素会出问题：IE会将img的空地址解析为当前页面地址的目录地址并请求。如当前网页地址为http://aaa.com/bb/c.html，img的地址会被解析为http://aaa.com/bb ②早些版本的Webkit和Firefox会将空连接解析为当前页面的地址。在ios与android中此问题较严重。如果页面有多个空连接属性元素，会增加服务器的请求次数。 ③幸运的是，主流浏览器对iframe的src属性值为空时，会解析为about:blank地址，而不发送额外请求。 3. 避免节点深层级嵌套层级越深的节点在初始化构建时，所占内存越多。通过浏览器HTML解析器会将整个HTML文档的结构存储为DOM树结构。当节点嵌套层次越深，构建的DOM书层次也越深。 4. 缩减HTML文档大小 ①删除对执行结果无影响的空格空行和注释； ②避免table布局； ③使用HTML5； 5.显式指定文档字符集在HTML页面开时指定字符集有助于浏览器立即开始解析HTML代码。HTML文档通常被解析为一序列的带字符集编码信息的字符串，通过Internet传送。字符集编码在HTTP响应头中，或HTML标记中指定。浏览器通过指定的字符集，吧编码解析为可现实在屏幕上的字符。若浏览器无法获知页面的编码字符集，一般会在执行脚本和渲染页面之前，先将字节流缓存，再搜索可进行解析的字符集 或 以默认字符集来解析。 6. 显示设置图片的宽高有时需要在页面加载完之前，就对页面布局进行定位。若页面中的图片没指定尺寸，或尺寸与实际图片大小不符，浏览器会在图片下载完成后再”回溯”该图片并重新显示，从而浪费时间。故最好为页面的图片设置指定尺寸（行内样式或CSS样式） 7. 避免脚本阻塞加载浏览器在解析常规script标签时，会等待script下载完毕后，才解析执行，之后的HTML代码就只能等待。 CSS1. 避免使用@importCSS2.1加入的@import，会使页面在加载时添加额外延迟。由于浏览器不能并行下载样式，会导致页面增添额外的往返耗时。而使用能并行下载样式，但任然是多次请求。 2. 避免AlphaImageLoader滤镜此滤镜能解决IE6即一下版本显示PNG图片的半透明效果，但会在加载图片时终止内容的呈现，并冻结浏览器。在每个元素(不仅仅是图片)都会运算一次，添加内存开支。应使用PNG8格式来代替，或用下划线(_filter)只针对IE6。 3. 避免CSS表达式CSS表达式是动态设置CSS属性的强大（但危险）方法。Internet Explorer从第5个版本开始支持CSS表达式12345678910111213141516隔1s切换一次背景颜色 input鼠标移入移出变换背景//cssbody&#123; background-color: expression( (new Date()).getSeconds()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; ); &#125;input &#123; star : expression( onmouseover=function()&#123;this.style.backgroundColor=&quot;green&quot;&#125;, onmouseout=function()&#123;this.style.backgroundColor=&quot;red&quot;&#125; ) &#125;//HTML&lt;body &gt; &lt;input type=&quot;text&quot;/&gt;&lt;/body&gt; css表达式算频率要比我们想象的多。千上万次并且可能会对你页面的性能产生影响。在页面滚动、乃至移动鼠标时都会要重新计算一次。随便移动鼠标都可以轻松达到10000次以上的计算量。 解决方案：如果样式属性必须在页面周期内动态地改变，使用事件句柄来代替CSS表达式，或者使用使用jQuery方法代替 4. 避免通配选择器优化选择器的原则是减少匹配时间。CSS选择器的匹配机制是：从右向左进行规制匹配的！ #header &gt; a { font-weight:blod;}这条规制实际是浏览器遍历页面所有a元素，并确定其父元素的id是否为header。 #header a {…} 后代选择器开销更大，在遍历页面的所有a元素后，会需向上遍历直到根节点。由此可知，选择器最右边的规制往往决定了向左移匹配的工作量。故最右边的选择规则 称之为关键选择器。 5. 避免单规则的属性选择器.selected [href=’#index’] {…}浏览器先匹配所有的元素，检查其是否有href属性并且值为“#index”，再分别向上匹配class为selected的元素。故应该避免使用关键选择器是单规则属性选择器的规则。 6.避免正则的属性选择器CSS3添加了复杂的属性选择器，通过类正则表达式进行匹配。但这些类型的选择器会比基于类别的匹配慢很多。 7.移除无匹配的样式 ①删除无用的样式，可缩减样式文件大小，加快加载速度。 ②对于浏览器，所有样式规则都会被解析后索引起来，即使是当前页面无匹配的规则！故移除无匹配的规则，减少索引项，加快浏览器查找速度。 JavaScript1.使用事件代理当过多的事件句柄被频繁触发时，页面反应会迟钝。如一个div有10个按钮，只需给div附加一次事件句柄，而不必给每个按钮添加一个句柄。 2.缓存选择器查询结果减少选择器查询的次数，并尽可能缓存选中的结果，便于以后的重用。123456789jQuery(&apos;#top&apos;).find(&apos;p.classA&apos;);...jQuery(&apos;#top&apos;).find(&apos;p.classB&apos;);//使用下面的方法 减少开销var cached = jQuery(&apos;#top&apos;);cached.find(&apos;p.classA&apos;);...cached.find(&apos;p.classB&apos;); 3.避免频繁的IO操作(读写操作)应减少对cookie或localstorage的操作，因为对它们进行操作的API是同步的，而它们是多个tab页面间共享的。多页面同时操作cookie和localstorage时，会存在同步加锁机制。 4. 避免频繁的DOM操作JavaScript访问DOM元素缓慢，应做到： ①缓存已经查询过的元素； ②线下更新完节点之后，在将它们添加到文档树中； ③避免使用JavaScript来修改页面布局。 5.使用微类库尽量避免使用大而全的类库，而是按需使用微类库来辅助开发。因为大而全的类库好多代码是不需要的，浪费加载时间 参考文章：高性能web推荐文章：唯快不破：Web 应用的 13 个优化步骤","tags":[{"name":"网站优化","slug":"网站优化","permalink":"https://angeljie889.github.io/tags/网站优化/"}]}]