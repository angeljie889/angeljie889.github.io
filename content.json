[{"title":"日常String、Number、Array、Math和Json方法","date":"2017-04-20T14:36:36.000Z","path":"2017/04/20/日常String、Number、Array、Math和Json方法/","text":"前端日常使用的方法有很多种，为了方便使用和查询，整理如下 字符串方法1234567891011121314String.length() 返回字符串的长度String.charAt() 返回字符串中指定位置的字符String.charCodeAt() 返回指定位置的字符的Unicode 编码String.indexOf() 返回指定值在调用该方法的字符串中首次出现的位置String.lastIndexOf() 返回指定值在调用该方法的字符串中最后出现的位置String.slice() 提取字符串中的一部分，并返回这个新的字符串String.split() 通过一个指定的字符串分隔符，把原字符串分割成一个数组String.substring() 截取指定位置之间的字符串String.substr() 截取指定起始位置和长度的子字符串String.toLowerCase() 把字符串全部转成小写String.toUpperCase() 把字符串全部转成大写String.trim() 去掉字符串首尾的全部空格str.repeat(num) 将str复制几分并返回，num代表复制的次数。str.includes() 参数：1、要查找的字符串2、起始位置返回布尔值 注意 slice(),substr(),substring()方法的不同三种方法都是返回被操作字符串的子字符串，都接受一或者两个参数，第一个参数指定子字符串的开始位置，第二个参数在指定的情况下表示子字符串在哪里结束。具体来说，slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置，而==substr() 的第二个参数指定的是返回的字符个数== 数组方法1234567891011121314151617181920212223242526272829303132arr.every(fun) 检测数值元素的每个元素是否都符合条件。arr.filter(fun) 检测数值元素，并返回符合条件所有元素的数组。arr.map(fun) 让数组的每一项都执行一次给定的函数,返回值是数组arr.forEach(fun) 让数组的每一项都执行一次给定的函数arr.some(fun) 检测数组元素中是否有元素符合指定条件。arr.sort(fun) 对数组的元素进行排序arr.push() 添加一个或多个元素到数组的末尾arr.unshift() 添加一个或多个元素到数组的头部arr.pop() 删除数组最后一项元素arr.shift() 删除数组第一个元素arr.concat(arr) 将传入的数组或非数组值与原数组合并,组成一个新的数组并返回arr.reverse() 颠倒数组中元素的位置arr.join(str) 用于把数组中的所有元素通过指定的分隔符进行分隔,放入字符串。arr.slice(num) 截取数组中一部分，并返回这个新的数组arr.splice(num) 用新元素替换旧元素以此修改数组的内容，3个参数，2个参数代表删除arr.toString() 把数组转换为字符串，并返回结果。arr.valueOf() 返回数组对象的原始值。arr.indexOf（） 参数在数组中的下标，返回值为number；-1代表数组中没有这个参数arr.from() 用于将类数组对象转为真正的数组arr.of() 用于将一组参数，转换为数组。 Arr.sort(function(a,b)&#123; //return a - b (从小到大)； //return b - a（从大到小） &#125;) 数组（json）随机排序： Arr.sort(function() &#123; return 0.5 - Math.random(); &#125;)（随机排序） //获取数组元素最小值和最大值 Math.min.apply(null,arr)； Math.max.apply(null,arr)； Math方法1234567891011Math.ceil() 对数进行向上取整Math.floor() 对数进行向下取整Math.round() 对数进行四舍五入Math.abs() 取数的绝对值Math.random() 取0-1之间的随机数，不包含1Math.min() 取（）里面的最小值Math.pow(a,b) a的b次方Math.pow(a,1/b) a的开b次方Math.sqrt(a) a的开方Math.sign() 判断一个数字是正数，负数还是零Math.hypot(...values) 返回所有参数的平方和的平方根(勾股定理) json操作方法12JSON.parse(str); 由JSON字符串转换为JSON对象JSON.stringify(obj); 将JSON对象转化为JSON字符","tags":[{"name":"string","slug":"string","permalink":"https://angeljie889.github.io/tags/string/"},{"name":"number","slug":"number","permalink":"https://angeljie889.github.io/tags/number/"},{"name":"array","slug":"array","permalink":"https://angeljie889.github.io/tags/array/"},{"name":"Math","slug":"Math","permalink":"https://angeljie889.github.io/tags/Math/"}]},{"title":"日常String、Number、Array、Math和Json方法","date":"2017-03-20T14:36:36.000Z","path":"2017/03/20/hello/","text":"前端日常使用的方法有很多种，为了方便使用和查询，整理如下 字符串方法1234567891011121314String.length() 返回字符串的长度String.charAt() 返回字符串中指定位置的字符String.charCodeAt() 返回指定位置的字符的Unicode 编码String.indexOf() 返回指定值在调用该方法的字符串中首次出现的位置String.lastIndexOf() 返回指定值在调用该方法的字符串中最后出现的位置String.slice() 提取字符串中的一部分，并返回这个新的字符串String.split() 通过一个指定的字符串分隔符，把原字符串分割成一个数组String.substring() 截取指定位置之间的字符串String.substr() 截取指定起始位置和长度的子字符串String.toLowerCase() 把字符串全部转成小写String.toUpperCase() 把字符串全部转成大写String.trim() 去掉字符串首尾的全部空格str.repeat(num) 将str复制几分并返回，num代表复制的次数。str.includes() 参数：1、要查找的字符串2、起始位置返回布尔值 注意 slice(),substr(),substring()方法的不同三种方法都是返回被操作字符串的子字符串，都接受一或者两个参数，第一个参数指定子字符串的开始位置，第二个参数在指定的情况下表示子字符串在哪里结束。具体来说，slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置，而==substr() 的第二个参数指定的是返回的字符个数== 数组方法1234567891011121314151617181920212223242526272829303132arr.every(fun) 检测数值元素的每个元素是否都符合条件。arr.filter(fun) 检测数值元素，并返回符合条件所有元素的数组。arr.map(fun) 让数组的每一项都执行一次给定的函数,返回值是数组arr.forEach(fun) 让数组的每一项都执行一次给定的函数arr.some(fun) 检测数组元素中是否有元素符合指定条件。arr.sort(fun) 对数组的元素进行排序arr.push() 添加一个或多个元素到数组的末尾arr.unshift() 添加一个或多个元素到数组的头部arr.pop() 删除数组最后一项元素arr.shift() 删除数组第一个元素arr.concat(arr) 将传入的数组或非数组值与原数组合并,组成一个新的数组并返回arr.reverse() 颠倒数组中元素的位置arr.join(str) 用于把数组中的所有元素通过指定的分隔符进行分隔,放入字符串。arr.slice(num) 截取数组中一部分，并返回这个新的数组arr.splice(num) 用新元素替换旧元素以此修改数组的内容，3个参数，2个参数代表删除arr.toString() 把数组转换为字符串，并返回结果。arr.valueOf() 返回数组对象的原始值。arr.indexOf（） 参数在数组中的下标，返回值为number；-1代表数组中没有这个参数arr.from() 用于将类数组对象转为真正的数组arr.of() 用于将一组参数，转换为数组。 Arr.sort(function(a,b)&#123; //return a - b (从小到大)； //return b - a（从大到小） &#125;) 数组（json）随机排序： Arr.sort(function() &#123; return 0.5 - Math.random(); &#125;)（随机排序） //获取数组元素最小值和最大值 Math.min.apply(null,arr)； Math.max.apply(null,arr)； Math方法1234567891011Math.ceil() 对数进行向上取整Math.floor() 对数进行向下取整Math.round() 对数进行四舍五入Math.abs() 取数的绝对值Math.random() 取0-1之间的随机数，不包含1Math.min() 取（）里面的最小值Math.pow(a,b) a的b次方Math.pow(a,1/b) a的开b次方Math.sqrt(a) a的开方Math.sign() 判断一个数字是正数，负数还是零Math.hypot(...values) 返回所有参数的平方和的平方根(勾股定理) json操作方法12JSON.parse(str); 由JSON字符串转换为JSON对象JSON.stringify(obj); 将JSON对象转化为JSON字符","tags":[{"name":"string","slug":"string","permalink":"https://angeljie889.github.io/tags/string/"},{"name":"number","slug":"number","permalink":"https://angeljie889.github.io/tags/number/"},{"name":"array","slug":"array","permalink":"https://angeljie889.github.io/tags/array/"},{"name":"Math","slug":"Math","permalink":"https://angeljie889.github.io/tags/Math/"}]},{"title":"前端优化","date":"2017-03-20T12:36:36.000Z","path":"2017/03/20/hello-world/","text":"前端是庞大的，包括 HTML、 CSS、 Javascript、Image 、Flash等等各种各样的资源。前端优化是复杂的，针对方方面面的资源都有不同的方式。那么，前端优化的目的是什么 ? 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。前端优化的途径有很多，按粒度大致可以分为两类，第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ;第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。另外，本着提高投入产出比的目的，后文提到的各种优化策略大致按照投入产出比从大到小的顺序排列。 页面级优化11. 减少 HTTP请求数 这条策略基本上所有前端人都知道，而且也是最重要最有效的。都说要减少 HTTP请求，那请求多了到底会怎么样呢 ?首先，每个请求都是有成本的，既包含时间成本也包含资源成本。一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。时间成本就是用户需要看到或者 “感受” 到这个资源是必须要等待这个过程结束的，资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。另外，由于浏览器进行并发请求的请求数是有上限的 (具体参见此处 )，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，会给用户造成站点速度慢这样一个印象，即使可能用户能看到的第一屏的资源都已经请求完了，但是浏览器的进度条会一直存在。 减少 HTTP请求数的主要途径包括： (1). 从设计实现层面简化页面 如果你的页面像百度首页一样简单，那么接下来的规则基本上都用不着了。保持页面简洁、减少资源的使用时最直接的。如果不是这样，你的页面需要华丽的皮肤，则继续阅读下面的内容。 (2). 合理设置 HTTP缓存 缓存的力量是强大的，恰当的缓存设置可以大大的减少 HTTP请求。以有啊首页为例，当浏览器没有缓存的时候访问一共会发出 78个请求，共 600多 K数据 (如图 1.1)，而当第二次访问即浏览器已缓存之后访问则仅有 10个请求，共 20多 K数据 (如图 1.2)。 (这里需要说明的是，如果直接 F5刷新页面的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是 304响应，只有 Header没有Body ，可以节省带宽 ) 怎样才算合理设置 ?原则很简单，能缓存越多越好，能缓存越久越好。例如，很少变化的图片资源可以直接通过 HTTP Header中的Expires设置一个很长的过期头 ;变化不频繁而又可能会变的资源可以使用 Last-Modifed来做请求验证。尽可能的让资源能够在缓存中待得更久。关于 HTTP缓存的具体设置和原理此处就不再详述了，有兴趣的可以参考下列文章：HTTP1.1协议中关于缓存策略的描述Fiddler HTTP Performance中关于缓存的介绍 (3). 资源合并与压缩 如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外， CSS、 Javascript、Image 都可以用相应的工具进行压缩，压缩后往往能省下不少空间。 (4). CSS Sprites 合并 CSS图片，减少请求数的又一个好办法。 (5). Inline Images 使用 data: URL scheme的方式将图片嵌入到页面或 CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法。如果是嵌入页面的话换来的是增大了页面的体积，而且无法利用浏览器缓存。使用在 CSS中的图片则更为理想一些。 (6). Lazy Load Images（自己对这一块的内容还是不了解） 这条策略实际上并不一定能减少 HTTP请求数，但是却能在某些条件下或者页面刚加载时减少 HTTP请求数。对于图片而言，在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。 有啊首页 曾经的做法是在加载的时候把第一屏之后的图片地址缓存在 Textarea标签中，待用户往下滚屏的时候才 “惰性” 加载。 2. 将外部脚本置底（将脚本内容在页面信息内容加载后再加载） 前文有谈到，浏览器是可以并发请求的，这一特点使得其能够更快的加载资源，然而外链脚本在加载时却会阻塞其他资源，例如在脚本加载完成之前，它后面的图片、样式以及其他脚本都处于阻塞状态，直到脚本加载完成后才会开始加载。如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。解决这一问题的方法有很多，在 这里有比较详细的介绍 (这里是译文和 更详细的例子 )，而最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。 3. 异步执行 inline脚本(其实原理和上面是一样，保证脚本在页面内容后面加载。) inline脚本对性能的影响与外部脚本相比，是有过之而无不及。首页，与外部脚本一样， inline脚本在执行的时候一样会阻塞并发请求，除此之外，由于浏览器在页面处理方面是单线程的，当 inline脚本在页面渲染之前执行时，页面的渲染工作则会被推迟。简而言之， inline脚本在执行的时候，页面处于空白状态。鉴于以上两点原因，建议将执行时间较长的 inline脚本异步执行，异步的方式有很多种，例如使用 script元素的defer 属性(存在兼容性问题和其他一些问题，例如不能使用 document.write)、使用setTimeout ，此外，在HTML5中引入了 Web Workers的机制，恰恰可以解决此类问题。 4. Lazy Load Javascript（只有在需要加载的时候加载，在一般情况下并不加载信息内容。） 随着 Javascript框架的流行，越来越多的站点也使用起了框架。不过，一个框架往往包括了很多的功能实现，这些功能并不是每一个页面都需要的，如果下载了不需要的脚本则算得上是一种资源浪费 -既浪费了带宽又浪费了执行花费的时间。目前的做法大概有两种，一种是为那些流量特别大的页面专门定制一个专用的 mini版框架，另一种则是 Lazy Load。YUI 则使用了第二种方式，在 YUI的实现中，最初只加载核心模块，其他模块可以等到需要使用的时候才加载。 5. 将 CSS放在 HEAD中 如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕。除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟。 6. 异步请求 Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容） 在某些页面中可能存在这样一种需求，需要使用 script标签来异步的请求数据。类似： Javascript:/*Callback 函数*/ function myCallback(info)&#123; //do something here &#125; HTML: cb返回的内容 :myCallback(&apos;Hello world!&apos;); 像以上这种方式直接在页面上写 &lt;script&gt;对页面的性能也是有影响的，即增加了页面首次加载的负担，推迟了 DOMLoaded和window.onload 事件的触发时机。如果时效性允许的话，可以考虑在 DOMLoaded事件触发的时候加载，或者使用 setTimeout方式来灵活的控制加载的时机。 7. 减少不必要的 HTTP跳转 对于以目录形式访问的 HTTP链接，很多人都会忽略链接最后是否带 ’/&apos;，假如你的服务器对此是区别对待的话，那么你也需要注意，这其中很可能隐藏了 301跳转，增加了多余请求。具体参见下图，其中第一个链接是以无 ’/&apos;结尾的方式访问的，于是服务器有了一次跳转。 8. 避免重复的资源请求 这种情况主要是由于疏忽或页面由多个模块拼接而成，然后每个模块中请求了同样的资源时，会导致资源的重复请求","tags":[]}]